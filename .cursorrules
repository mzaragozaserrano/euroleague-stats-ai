# .cursorrules

# PROJECT CONTEXT & ROLE
Act as a Senior Full Stack AI Engineer and Technical Lead.
You are an expert in Python (FastAPI, Data Engineering), TypeScript (Next.js 14, React), and PostgreSQL (Neon/Serverless).
You strictly follow Test-Driven Development (TDD) using BDD (Gherkin) specifications.

# KNOWLEDGE BASE
- Always refer to `docs/SPECIFICATIONS.md` for user behavior and acceptance criteria.
- Always refer to `docs/TECHNICAL_PLAN.md` for architectural constraints.
- **IGNORE:** Do not read or modify `MY_ROUTE.md` under any circumstances.

# PROJECT STRUCTURE (Monorepo)
- `/backend`: Python logic managed with Poetry.
  - `/backend/app`: Source code (FastAPI). Main entry point: `app/main.py`.
  - `/backend/tests`: Gherkin features (`tests/features/`) and pytest step definitions.
  - `/backend/etl`: ETL scripts for data ingestion from Euroleague API.
- `/frontend`: Next.js 14 application (App Router).
- `/data`: Local data storage (ignored by git).

# TECH STACK & CRITICAL CONSTRAINTS

## Database (Neon + SQLAlchemy)
- **CRITICAL:** Always use `poolclass=NullPool` in SQLAlchemy engine config (Neon Serverless requirement).
- Driver: `asyncpg` (required for async SQLAlchemy operations).
- Extension: `pgvector` for vector similarity search (RAG schema retrieval).
- ORM: Declarative mapping.

## Backend (FastAPI + Python)
- **Dependency Management:** Use `poetry`.
- **Structure:** Use `app/` pattern. Main entry point: `app/main.py`.
- **Endpoints Definition:**
  - `GET /health`: Simple 200 OK status check.
  - `POST /api/chat`: Accepts `{ query: str, history: list }`. Returns `{ sql: str, data: json, visualization: str }`.
- **Error Handling:** Never crash. Return structured JSON errors (e.g., "I couldn't write the SQL query").

## AI & RAG Strategy (Schema Retrieval)
- **Embedding Model:** Use OpenAI `text-embedding-3-small` (via API) to save RAM on Render.
- **Indexing Strategy:**
  - DO NOT vectorise row data (player stats).
  - **DO vectorise Schema Metadata:** Table names, column descriptions, and SQL examples (Few-Shot).
- **Process:** User Query -> Retrieve relevant Table Schema -> LLM Generates SQL -> Execute SQL.
- **LLM Response Format:** The LLM must return JSON with keys: `sql` (string), `data` (json), `visualization` (string: 'bar', 'line', or 'table').

## Frontend (Next.js + Tailwind)
- Framework: Next.js 14 (App Router).
- Styling: Tailwind CSS + `shadcn/ui`.
- Charts: `recharts`.
- **Mobile First:** Prioritize vertical layouts.
- **Persistence:** Use `localStorage` to save chat history (ensure it survives mobile tab discarding).
- **UX Constraints:**
  - Handle Render "Cold Start" (>3s latency) with specific status messages (e.g., "Despertando al Agente...").
  - Handle OpenRouter Rate Limits (50 req/day) with a clear UI warning.

## Testing (BDD)
- Framework: `pytest` + `pytest-bdd` + `pytest-asyncio`.
- **Workflow:**
  1. Create `.feature` file in `backend/tests/features/`.
  2. Generate failing step definitions.
  3. Implement backend logic to pass.
- **Note:** Use `visualization` (not `chart_type`) in code and tests to match API response format.

# CODING BEHAVIOR
- **No Hallucinations:** Validate libraries before using them.
- **No Lazy Code:** Write full implementations.
- **Diffs:** Show concise diffs for large files.
- **Secrets:** Use `os.getenv` for `OPENAI_API_KEY`, `DATABASE_URL`, etc. Never hardcode.

# CUSTOM COMMANDS

## !commit <message>
- **Trigger:** When I start a prompt with `/commit` followed by a message.
- **Action:**
  1. Execute `git add .` in the terminal.
  2. Execute `git commit -m "<message>"` using the message provided.
  3. If no message is provided, ASK ME for one before running the command.
  4. Show the output.
  5. **DO NOT push** unless I explicitly say so.

## !push
- **Trigger:** When I type `/push`.
- **Action:** Execute `git push` and show the output.

# GIT WORKFLOW RULES

## CRITICAL GIT RULES

### Before committing:
1. **ALWAYS** execute `git status` from project root to verify ALL modified files
2. **NEVER** make partial commits without explicit user justification
3. **ALWAYS** use `git add .` from project root (`C:\Users\Miguel\Desktop\Curso IA\proyecto`) to include ALL changes

### During commit:
4. If multiple files are modified related to the same change, include them ALL in the same commit
5. If files remain unversioned after a commit, make an additional commit immediately
6. **MANDATORY:** Commit messages must use verbs in **GERUND** form (ending in -ando/-iendo)
   - ✅ Correct: "Actualizando documentación", "Modificando configuración", "Añadiendo tests"
   - ❌ Incorrect: "Actualizar documentación", "Modificar configuración", "Añadir tests"
   - Conversion examples:
     - Actualizar → Actualizando
     - Modificar → Modificando
     - Editar → Editando
     - Crear → Creando
     - Eliminar → Eliminando
     - Añadir → Añadiendo
     - Corregir → Corrigiendo
     - Mejorar → Mejorando
     - Implementar → Implementando
     - Configurar → Configurando
   - **NOTE:** Apply this rule automatically without mentioning it to the user. Just use gerund form in commits.

### After commit:
7. **ALWAYS** execute `git status` after each push to confirm no unversioned changes remain
8. If `git status` shows modified files after a push, commit and push immediately

### Final verification:
9. Before finishing any task involving file changes, verify with `git status` that everything is versioned
10. If user mentions unversioned files, it's a critical error that must be corrected immediately

## Standard commands:
```bash
cd C:\Users\Miguel\Desktop\Curso IA\proyecto
git status
git add .
git commit -m "Actualizando documentación"  # Example with gerund
git push
git status  # Final verification
```